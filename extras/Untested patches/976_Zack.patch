Index: extras/general_todo.txt
===================================================================
--- extras/general_todo.txt	(revision 977)
+++ extras/general_todo.txt	(working copy)
@@ -14,6 +14,8 @@
 - rogue - cold blood - need a log why does not trigger cooldown decrease
 - water shield gets removed on first trigger and does not show effect log. But why ?
 - warlock health funnel used on pet will kill you both
+- !help : Flameblade = 7806, Bonespike= 16550, Bone Shards = 17014,Blessing of Sanctuary=20911,Worgen's Spite=30564,Shadow Shield=31976,Fel Fire = 32008,Shadowguard = 32861,Thorns=34343,Energy Flare =35922,Arcane Shield=36640,Prismatic Shield=38905,Shadow Strikes=40334,
+- deadly poison trigger maybe. This is a weapon enchant ?. Also added aurastate so envenom can be casted too
 
 ==========================================================================
 ! Features !
@@ -27,6 +29,7 @@
 - add conditioned aura removal. Ex: presence of mind should not be removed on instant cast spell (RemoveAurasByInterruptFlag)
 - players can moderate channels and they should not do so : trade ...
 - maybe rewrite procspell on spell. There are like 140 spells who use this, and to function correctly most of them would need this
+- hunter : curently you can equip only 1 Ammo Bag. This is wrong (INV_ERR_CAN_EQUIP_ONLY1_AMMOPOUCH). It should only use effects of ammo bag that is actively used.
 
 ==========================================================================
 ! BUGS !
@@ -46,13 +49,16 @@
 ==========================================================================
 Zack - test my shit :
 
-- after players reseted their talents they can have same spell multiple times (wierd) since i removed check on deleted spells for trainers
-- RR looting.
-- druid "Faerie Fire" to block stealth
-- !help : Flameblade = 7806, Bonespike= 16550, Bone Shards = 17014,Blessing of Sanctuary=20911,Worgen's Spite=30564,Shadow Shield=31976,Fel Fire = 32008,Shadowguard = 32861,Thorns=34343,Energy Flare =35922,Arcane Shield=36640,Prismatic Shield=38905,Shadow Strikes=40334,
-- deadly poison trigger maybe. This is a weapon enchant ?. Also added aurastate so envenom can be casted too
-- hunter : curently you can equip only 1 Ammo Bag. This is wrong (INV_ERR_CAN_EQUIP_ONLY1_AMMOPOUCH). It should only use effects of ammo bag that is actively used.
-- trainers teaching talents and reteaching spells
+- quest items are stacked in backpack (usless)
+- prospecting and disenchanting results are stacked in backpack
+- minable things can be mined more then once
+- removed glancing blow until proper fix is found. Right now to many players do not make any dmg at all
+- paladin - illumination
+- paladin - Surge of Light
+- rogue - Ruthlessness
+- rogue - Relentless Strikes
+- hunter's mark to not agro creatures
+- warlock seed of corruption
 
 ==========================================================================
 
Index: src/game/MiscHandler.cpp
===================================================================
--- src/game/MiscHandler.cpp	(revision 977)
+++ src/game/MiscHandler.cpp	(working copy)
@@ -382,8 +382,31 @@
 			}
 			delete pGO;
 		}
+		//mining thingies can be mined more then once
 		else
 		{
+printf("!!!!!we are working with some go \n");
+			if(pGO->GetUInt32Value(GAMEOBJECT_TYPE_ID)==GAMEOBJECT_TYPE_CHEST)
+			{
+printf("Go is chest type and we have a spell %u \n",GetPlayer()->m_currentSpell!=NULL);
+				//we should make sure this is minable.=> last casted spell had open lock and locktype was LOCKTYPE_MINING ? Maybe there is an easier way :(
+				if(	GetPlayer()->m_currentSpell)
+				{
+					SpellEntry *se = GetPlayer()->m_currentSpell->m_spellInfo;
+					if( (se->EffectMiscValue[0]==LOCKTYPE_MINING && se->Effect[0]==SPELL_EFFECT_OPEN_LOCK) ||
+						(se->EffectMiscValue[1]==LOCKTYPE_MINING && se->Effect[1]==SPELL_EFFECT_OPEN_LOCK) ||
+						(se->EffectMiscValue[3]==LOCKTYPE_MINING && se->Effect[3]==SPELL_EFFECT_OPEN_LOCK))
+					{
+						//now see the ods to remove or not this GO from map
+printf("Are we trying to mine or not ? \n");
+						if(Rand(50))
+						{
+printf("We are keeping this resource on map right now \n");
+							return;
+						}
+					}
+				}
+			}
 			uint32 DespawnTime = 0;
 			if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
 				DespawnTime = 120000;	   // 5 min for quest GO,
Index: src/game/Player.cpp
===================================================================
--- src/game/Player.cpp	(revision 977)
+++ src/game/Player.cpp	(working copy)
@@ -3595,6 +3595,9 @@
 
 void Player::KillPlayer()
 {
+	//warlock - seed of corruption
+	HandleProc(PROC_ON_DIE,this,NULL);
+
 	setDeathState(JUST_DIED);
 
 	// Battleground stuff
Index: src/game/Professions.cpp
===================================================================
--- src/game/Professions.cpp	(revision 977)
+++ src/game/Professions.cpp	(working copy)
@@ -94,15 +94,26 @@
 			count = proto->Quality-2+rand()%3;
 		}
 	}
-
-	Item * it=objmgr.CreateItem(item,owner);
-   
-	it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
-	bool result = owner->GetItemInterface()->AddItemToFreeSlot(it);
-	if(!result)
+	Item *add;
+	SlotResult slotresult;
+	add = owner->GetItemInterface()->FindItemLessMax(item, count, false);
+	if (!add)
 	{
-		printf("Error whole trying to add disenchanted items to free slots");
+		slotresult = owner->GetItemInterface()->FindFreeInventorySlot(proto);
+		if(!slotresult.Result)
+		{
+			owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+			return;
+		}
+		Item * it=objmgr.CreateItem(item,owner);  
+		it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
+		owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
 	}
+	else
+	{
+		add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
+		add->m_isDirty = true;
+	}
 }
 
 /*
@@ -158,26 +169,38 @@
 		{
 			if(Rand(list->items[x].chance)) 
 		    {
-				Item * itm = objmgr.CreateItem(list->items[x].item.itemid,owner);
-				if(!itm) 
+				ItemPrototype *itemproto = ItemPrototypeStorage.LookupEntry(list->items[x].item.itemid);
+				if(!itemproto)
 					return;
 				uint32 count = 1;
 				if(list->count != (x - 1))
 				{
-					ItemPrototype *itemproto = ItemPrototypeStorage.LookupEntry(list->items[x].item.itemid);
 					for(uint32 z = (x + 1); z < list->count; z++)
 						if(itemproto->MaxCount && (count == itemproto->MaxCount))
 							break;
 						else if(list->items[x].item.itemid == list->items[z].item.itemid && Rand(list->items[x].chance))
 							count++;
 				}
-				itm->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
-				bool result = owner->GetItemInterface()->AddItemToFreeSlot(itm);
-				if(!result)
+				Item *add;
+				SlotResult slotresult;
+				add = owner->GetItemInterface()->FindItemLessMax(list->items[x].item.itemid, count, false);
+				if (!add)
 				{
-					owner->GetItemInterface()->BuildInventoryChangeError( 0, 0, INV_ERR_INVENTORY_FULL );
-					return;
+					slotresult = owner->GetItemInterface()->FindFreeInventorySlot(itemproto);
+					if(!slotresult.Result)
+					{
+						owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item * it=objmgr.CreateItem(list->items[x].item.itemid,owner);  
+					it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
+					owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
 				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
+					add->m_isDirty = true;
+				}
 			}
 		}
  	}
Index: src/game/QuestMgr.cpp
===================================================================
--- src/game/QuestMgr.cpp	(revision 977)
+++ src/game/QuestMgr.cpp	(working copy)
@@ -805,9 +805,26 @@
 			    }
 			    else
 			    {   
-				    Item *itm = objmgr.CreateItem(qst->reward_item[i], plr);
-				    itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_itemcount[i]));
-				    plr->GetItemInterface()->AddItemToFreeSlot(itm); //possible memleak and no safe check.
+					Item *add;
+					SlotResult slotresult;
+					add = plr->GetItemInterface()->FindItemLessMax(qst->reward_item[i], qst->reward_itemcount[i], false);
+					if (!add)
+					{
+						slotresult = plr->GetItemInterface()->FindFreeInventorySlot(proto);
+						if(!slotresult.Result)
+						{
+							plr->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+							return;
+						}
+						Item *itm = objmgr.CreateItem(qst->reward_item[i], plr);
+						itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_itemcount[i]));
+						plr->GetItemInterface()->SafeAddItem(itm,slotresult.ContainerSlot, slotresult.Slot);
+					}
+					else
+					{
+						add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + qst->reward_itemcount[i]);
+						add->m_isDirty = true;
+					}
 			    }
 		    }
 	    }
@@ -822,9 +839,26 @@
 		    }
 		    else
 		    {
-			    Item *itm = objmgr.CreateItem(qst->reward_choiceitem[reward_slot], plr);
-			    itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, qst->reward_choiceitemcount[reward_slot]);
-			    plr->GetItemInterface()->AddItemToFreeSlot(itm); //possible mem leak and no item check
+				Item *add;
+				SlotResult slotresult;
+				add = plr->GetItemInterface()->FindItemLessMax(qst->reward_choiceitem[reward_slot], qst->reward_choiceitemcount[reward_slot], false);
+				if (!add)
+				{
+					slotresult = plr->GetItemInterface()->FindFreeInventorySlot(proto);
+					if(!slotresult.Result)
+					{
+						plr->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item *itm = objmgr.CreateItem(qst->reward_choiceitem[reward_slot], plr);
+					itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_choiceitemcount[reward_slot]));
+					plr->GetItemInterface()->SafeAddItem(itm,slotresult.ContainerSlot, slotresult.Slot);
+				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + qst->reward_choiceitemcount[reward_slot]);
+					add->m_isDirty = true;
+				}
 		    }
 	    }
 
@@ -899,9 +933,26 @@
 			    }
 			    else
 			    {   
-				    Item *itm = objmgr.CreateItem(qst->reward_item[i], plr);
-				    itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_itemcount[i]));
-				    plr->GetItemInterface()->AddItemToFreeSlot(itm); //possible memleak and no safe check.
+					Item *add;
+					SlotResult slotresult;
+					add = plr->GetItemInterface()->FindItemLessMax(qst->reward_item[i], qst->reward_itemcount[i], false);
+					if (!add)
+					{
+						slotresult = plr->GetItemInterface()->FindFreeInventorySlot(proto);
+						if(!slotresult.Result)
+						{
+							plr->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+							return;
+						}
+						Item *itm = objmgr.CreateItem(qst->reward_item[i], plr);
+						itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_itemcount[i]));
+						plr->GetItemInterface()->SafeAddItem(itm,slotresult.ContainerSlot, slotresult.Slot);
+					}
+					else
+					{
+						add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + qst->reward_itemcount[i]);
+						add->m_isDirty = true;
+					}
 			    }
 		    }
 	    }
@@ -916,9 +967,26 @@
 		    }
 		    else
 		    {
-			    Item *itm = objmgr.CreateItem(qst->reward_choiceitem[reward_slot], plr);
-			    itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, qst->reward_choiceitemcount[reward_slot]);
-			    plr->GetItemInterface()->AddItemToFreeSlot(itm); //possible mem leak and no item check
+				Item *add;
+				SlotResult slotresult;
+				add = plr->GetItemInterface()->FindItemLessMax(qst->reward_choiceitem[reward_slot], qst->reward_choiceitemcount[reward_slot], false);
+				if (!add)
+				{
+					slotresult = plr->GetItemInterface()->FindFreeInventorySlot(proto);
+					if(!slotresult.Result)
+					{
+						plr->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item *itm = objmgr.CreateItem(qst->reward_choiceitem[reward_slot], plr);
+					itm->SetUInt32Value(ITEM_FIELD_STACK_COUNT, uint32(qst->reward_choiceitemcount[reward_slot]));
+					plr->GetItemInterface()->SafeAddItem(itm,slotresult.ContainerSlot, slotresult.Slot);
+				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + qst->reward_choiceitemcount[reward_slot]);
+					add->m_isDirty = true;
+				}
 		    }
 	    }
 
Index: src/game/Spell.cpp
===================================================================
--- src/game/Spell.cpp	(revision 977)
+++ src/game/Spell.cpp	(working copy)
@@ -3493,42 +3493,46 @@
 	// add threat
 	if(u_caster)
 	{
+		uint32 base_threat=GetBaseThreat(amount);
 		int count = 0;
 		Unit *unit;
 		std::vector<Unit*> target_threat;
-		target_threat.reserve(u_caster->GetInRangeCount()); // this helps speed
+		if(base_threat)
+		{
+			target_threat.reserve(u_caster->GetInRangeCount()); // this helps speed
 
-		for(std::set<Object*>::iterator itr = u_caster->GetInRangeSetBegin(); itr != u_caster->GetInRangeSetEnd(); ++itr)
-		{
-			if((*itr)->GetTypeId() != TYPEID_UNIT)
-				continue;
-			unit = static_cast<Unit*>((*itr));
-			if(unitTarget->IsBeingAttackedBy(unit) ||
-				unitTarget->getAttackTarget() == unit->GetGUID() ||
-				u_caster->IsBeingAttackedBy(unit) ||
-				u_caster->getAttackTarget() == unit->GetGUID())
+			for(std::set<Object*>::iterator itr = u_caster->GetInRangeSetBegin(); itr != u_caster->GetInRangeSetEnd(); ++itr)
 			{
-				target_threat.push_back(unit);
-				++count;
+				if((*itr)->GetTypeId() != TYPEID_UNIT)
+					continue;
+				unit = static_cast<Unit*>((*itr));
+				if(unitTarget->IsBeingAttackedBy(unit) ||
+					unitTarget->getAttackTarget() == unit->GetGUID() ||
+					u_caster->IsBeingAttackedBy(unit) ||
+					u_caster->getAttackTarget() == unit->GetGUID())
+				{
+					target_threat.push_back(unit);
+					++count;
+				}
 			}
-		}
-		if(count == 0)
-			count = 1;  // division against 0 protection
-		/* 
-		When a tank hold multiple mobs, the threat of a heal on the tank will be split between all the mobs.
-		The exact formula is not yet known, but it is more than the Threat/number of mobs.
-		So if a tank holds 5 mobs and receives a heal, the threat on each mob will be less than Threat(heal)/5.
-		Current speculation is Threat(heal)/(num of mobs *2)
-		*/
-		uint32 threat = amount / (count * 2);
-			
-		for(std::vector<Unit*>::iterator itr = target_threat.begin(); itr != target_threat.end(); ++itr)
-		{
-			// for now we'll just use heal amount as threat.. we'll prolly need a formula though
-			((Unit*)(*itr))->GetAIInterface()->HealReaction(u_caster, unitTarget, threat);
+			if(count == 0)
+				count = 1;  // division against 0 protection
+			/* 
+			When a tank hold multiple mobs, the threat of a heal on the tank will be split between all the mobs.
+			The exact formula is not yet known, but it is more than the Threat/number of mobs.
+			So if a tank holds 5 mobs and receives a heal, the threat on each mob will be less than Threat(heal)/5.
+			Current speculation is Threat(heal)/(num of mobs *2)
+			*/
+			uint32 threat = base_threat / (count * 2);
+				
+			for(std::vector<Unit*>::iterator itr = target_threat.begin(); itr != target_threat.end(); ++itr)
+			{
+				// for now we'll just use heal amount as threat.. we'll prolly need a formula though
+				((Unit*)(*itr))->GetAIInterface()->HealReaction(u_caster, unitTarget, threat);
 
-			if((*itr)->GetGUID() == u_caster->getAttackTarget())
-				doneTarget = 1;
+				if((*itr)->GetGUID() == u_caster->getAttackTarget())
+					doneTarget = 1;
+			}
 		}
 
 		if(!u_caster->isInCombat() && unitTarget->isInCombat() && unitTarget->IsInWorld())
Index: src/game/Spell.h
===================================================================
--- src/game/Spell.h	(revision 977)
+++ src/game/Spell.h	(working copy)
@@ -237,6 +237,7 @@
 	PROC_ON_TRAP_TRIGGERED		  = 0x200000,
 	PROC_ON_AUTO_SHOT_HIT			= 0x400000,
 	PROC_UNUSED2					= 0x800000,
+	PROC_ON_DIE						= 0x4000000,//added it as custom, maybe already exists in another form ?
 	PROC_REMOVEONUSE				= 0x8000000,//remove prochcharge only when it is used
 	PROC_MISC						= 0x10000000,//our custom flag to decide if proc dmg or shield
 	PROC_ON_BLOCK_VICTIM			= 0x20000000,//added it as custom, maybe already exists in another form ?
@@ -863,6 +864,7 @@
 	SPELL_TYPE_SPIRIT				= 65536,
 	SPELL_TYPE_MAGE_AMPL_DUMP		= 131072,
 	SPELL_TYPE_WARLOCK_IMMOLATE		= 262144, //maybe there is a better way to trigger the aurastate for imolate spell
+	SPELL_TYPE_FINISHING_MOVE		= 524288, 
 };
 
 inline bool IsInrange(float x1,float y1, float z1, Object * o,float square_r)
@@ -1157,6 +1159,7 @@
 
 	SpellEntry * m_spellInfo;
 	uint32 pSpellId;
+	SpellEntry *ProcedOnSpell; //some spells need to know the origins of the proc too
 	SpellCastTargets m_targets;
 
 	void CreateItem(uint32 itemId);
@@ -1383,6 +1386,19 @@
 		return Rad[i];
 	}
 
+	inline uint32 GetBaseThreat(uint32 dmg)
+	{
+		//there should be a formula to determine what spell cause threat and which don't
+		switch(m_spellInfo->NameHash)
+		{
+			//hunter's mark
+			case 4287212498:
+				{
+					return 0;
+				}break;
+		}
+		return dmg;
+	}
 	bool IsStealthSpell();
 	bool IsInvisibilitySpell();
 	
Index: src/game/SpellAuras.cpp
===================================================================
--- src/game/SpellAuras.cpp	(revision 977)
+++ src/game/SpellAuras.cpp	(working copy)
@@ -1545,6 +1545,44 @@
 				if(caster && caster->IsPlayer())
 					static_cast<Player*>(caster)->SetTriggerStunOrImmobilize(12494,mod->m_amount);
 			}break;
+		//warlock - seed of corruption
+		case 27243:
+		case 32863:
+		case 36123:
+		case 38252:
+		case 39367:
+			{
+				//register a cast on death of the player
+				if(apply)
+				{
+					ProcTriggerSpell pts;
+					pts.origId = GetSpellProto()->Id;
+					pts.caster = m_casterGuid;
+//					pts.spellId=GetSpellProto()->Id;
+					pts.spellId=32865;
+					if(!pts.spellId)
+						return;
+					pts.procChance = GetSpellProto()->procChance;
+//					pts.procFlags = GetSpellProto()->procFlags;
+					pts.procFlags = PROC_ON_DIE;
+					pts.procCharges = GetSpellProto()->procCharges;
+					pts.LastTrigger = 0;
+					pts.deleted = false;
+					m_target->m_procSpells.push_front(pts);
+				}
+				else
+				{
+					for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+					{
+						if(itr->origId == GetSpellId() && itr->caster == m_casterGuid)
+						{
+							//m_target->m_procSpells.erase(itr);
+							itr->deleted = true;
+							break;
+						}
+					}
+				}
+			}break;
 	}
 }
 
Index: src/game/SpellEffects.cpp
===================================================================
--- src/game/SpellEffects.cpp	(revision 977)
+++ src/game/SpellEffects.cpp	(working copy)
@@ -1668,6 +1668,13 @@
 	//yess there is always someone special : shamanistic rage - talent
 	if(m_spellInfo->Id==30824)
 		totalEnergy = curEnergy+damage*GetUnitTarget()->GetAP()/100;
+	//paladin illumination
+	else if(m_spellInfo->Id==20272 && ProcedOnSpell)
+	{
+		SpellEntry *motherspell=sSpellStore.LookupEntry(pSpellId);
+		if(motherspell)
+			totalEnergy = (motherspell->EffectBasePoints[0]+1)*ProcedOnSpell->manaCost/100;
+	}
 	else  totalEnergy = curEnergy+damage;
 	if(totalEnergy > maxEnergy)
 		unitTarget->SetUInt32Value(POWER_TYPE,maxEnergy);
Index: src/game/Unit.cpp
===================================================================
--- src/game/Unit.cpp	(revision 977)
+++ src/game/Unit.cpp	(working copy)
@@ -787,6 +787,23 @@
 								//nothing else to be done for this trigger
 								continue;
 							}break;
+						//rogue - Ruthlessness
+						case 14157:
+							{
+								//we need a finishing move for this 
+								if(ospinfo->buffType!=SPELL_TYPE_FINISHING_MOVE)
+									continue;
+							}break;
+						//rogue - Relentless Strikes
+						case 14181:
+							{
+								int32 proc_Chance;
+								//chance is based actually on combopoint count and not 100% always 
+								if(ospinfo->buffType==SPELL_TYPE_FINISHING_MOVE && spellId==14181 && IsPlayer())
+									proc_Chance = static_cast<Player*>(this)->m_comboPoints*(ospinfo->EffectBasePoints[0]+1);
+								if(!Rand(proc_Chance))
+									continue;
+							}break;
 					}
 				}
 				if(spellId==22858 && isInBack(victim)) //retatliation needs target to be not in front. Can be casted by creatures too
@@ -802,6 +819,7 @@
 				{
 					spell->pSpellId=itr2->spellId;
 					spell->SpellEffectDummy(0);
+					spell->ProcedOnSpell = CastingSpell;
 					delete spell;
 					continue;
 				}
@@ -858,7 +876,12 @@
 							if(victim==this || isFriendly(this, victim))
 								continue;
 						}break;
-
+						//paladin - Surge of Light
+					case 33151:
+						{
+							if( CastingSpell->NameHash!=2272412495)//smite
+								continue;
+						}break;
 					}
 				}
 				if(iter2->second.lastproc!=0)
@@ -1454,7 +1477,7 @@
 						}
 					}
 				}
-				else if(!pVictim->IsPlayer()&&(!ability))	//glancing
+/*				else if(!pVictim->IsPlayer()&&(!ability))	//glancing
 				{
 					if(damage_type != RANGED)
 					{
@@ -1464,12 +1487,15 @@
 							if(damage_reduction > 0)
 							{
 								dmg.full_damage -= (damage_reduction*dmg.full_damage)/100;
-                                if(dmg.full_damage <= 0) dmg.full_damage = 1;
+                                if(dmg.full_damage <= 0)
+								{
+									dmg.full_damage = 1;
+								}
 								hit_status |= HITSTATUS_GLANCING;
 							}
 						}
 					}
-				}
+				}*/
 			}	
 			//absorb apply
 			uint32 dm = dmg.full_damage;
Index: src/game/World.cpp
===================================================================
--- src/game/World.cpp	(revision 977)
+++ src/game/World.cpp	(working copy)
@@ -583,6 +583,8 @@
 			type |= SPELL_TYPE_WARLOCK_IMMOLATE;
 		else if(strstr(nametext, "Amplify Magic") || strstr(nametext, "Dampen Magic"))
 			type |= SPELL_TYPE_MAGE_AMPL_DUMP;
+		else if(strstr(nametext, "Finishing move")==nametext)
+			type |= SPELL_TYPE_FINISHING_MOVE;
 
 		/*FILE * f = fopen("C:\\spells.txt", "a");
 		fprintf(f, "case 0x%08X:		// %s\n", namehash, nametext);
@@ -824,6 +826,8 @@
 							pr|=PROC_ON_CAST_SPELL;
 						else if(strstr(desc,"chance to daze the target"))
 							pr|=PROC_ON_CAST_SPELL;
+						else if(strstr(desc,"finishing moves"))
+							pr|=PROC_ON_CAST_SPELL;
 //						else if(strstr(desc,"shadow bolt, shadowburn, soul fire, incinerate, searing pain and conflagrate"))
 //							pr|=PROC_ON_CAST_SPELL|PROC_TAGRGET_SELF;
 						//we should find that specific spell (or group) on what we will trigger
@@ -871,6 +875,8 @@
 						pr|=PROC_ON_CAST_SPELL;		//this happens only on hit ;)
 					if(strstr(desc,"shadow damage spells have"))
 						pr|=PROC_ON_CAST_SPELL;
+					if(strstr(desc,"your spell criticals have"))
+						pr|=PROC_ON_SPELL_CRIT_HIT | PROC_ON_SPELL_CRIT_HIT_VICTIM;
 //					if(strstr(desc,"chill effect to your Blizzard"))
 //						pr|=PROC_ON_CAST_SPELL;	
 					//////////////////////////////////////////////////
@@ -945,7 +951,7 @@
 			sp->proc_interval = 3000; //few seconds
 		}
 		//mage ignite talent should proc only on some chances
-		if(strstr(nametext, "Ignite") && sp->Id>=11119 && sp->Id<=12848 && sp->EffectApplyAuraName[0]==4)
+		else if(strstr(nametext, "Ignite") && sp->Id>=11119 && sp->Id<=12848 && sp->EffectApplyAuraName[0]==4)
 		{
 			//check if we can find in the desription
 			char *startofid=strstr(desc, "an additional ");
@@ -960,17 +966,17 @@
 			sp->procFlags = PROC_ON_SPELL_CRIT_HIT; //add procflag here since this was not processed with the others !
 		}
 		// Winter's Chill handled by frost school
-		if(strstr(nametext, "Winter's Chill"))
+		else if(strstr(nametext, "Winter's Chill"))
 		{
 			sp->School = 4;
 		}
 		// Blackout handled by Shadow school
-		if(strstr(nametext, "Blackout"))
+		else if(strstr(nametext, "Blackout"))
 		{
 			sp->School = 5;
 		}
 		// Shadow Weaving
-		if(strstr(nametext, "Shadow Weaving"))
+		else if(strstr(nametext, "Shadow Weaving"))
 		{
 			sp->School = 5;
 			sp->EffectApplyAuraName[0] = 42;
@@ -978,7 +984,7 @@
 			sp->procFlags = PROC_ON_CAST_SPECIFIC_SPELL;
 		}
 		//Improved Aspect of the Hawk
-		if(strstr(nametext, "Improved Aspect of the Hawk"))
+		else if(strstr(nametext, "Improved Aspect of the Hawk"))
 			sp->EffectSpellGroupRelation[1] = 0x100000;
 		//more triggered spell ids are wrong. I think blizz is trying to outsmart us :S
 		else if( strstr(nametext, "Nature's Guardian"))
@@ -1013,6 +1019,8 @@
 			sp->proc_interval = 10000; //10 seconds
 		else if(strstr(nametext, "Aviana's Purpose"))
 			sp->proc_interval = 10000; //10 seconds
+		else if(strstr(nametext, "Illumination"))
+			sp->EffectTriggerSpell[0]=20272;
 		//sp->dummy=result;
 /*		//if there is a proc spell and has 0 as charges then it's probably going to triger infinite times. Better not save these
 		if(sp->procCharges==0)
@@ -1256,6 +1264,44 @@
 		sp->EffectImplicitTargetB[1]=0;
 		sp->EffectImplicitTargetB[2]=0;
 	}
+	//Relentless Strikes
+	sp = sSpellStore.LookupEntry(14179);
+	if(sp)
+	{
+		sp->EffectApplyAuraName[0]=42;//proc spell
+		sp->procFlags = PROC_ON_CAST_SPELL;
+	}
+/*	//warlock - seed of corruption
+	sp = sSpellStore.LookupEntry(27243);
+	if(sp)
+	{
+		sp->EffectTriggerSpell[1] = 27285;
+		sp->procFlags = PROC_ON_DIE;
+	}
+	sp = sSpellStore.LookupEntry(32863);
+	if(sp)
+	{
+		sp->EffectTriggerSpell[1] = 32865;
+		sp->procFlags = PROC_ON_DIE;
+	}
+	sp = sSpellStore.LookupEntry(36123);
+	if(sp)
+	{
+		sp->EffectTriggerSpell[1] = 32865;
+		sp->procFlags = PROC_ON_DIE;
+	}
+	sp = sSpellStore.LookupEntry(38252);
+	if(sp)
+	{
+		sp->EffectTriggerSpell[1] = 32865;
+		sp->procFlags = PROC_ON_DIE;
+	}
+	sp = sSpellStore.LookupEntry(39367);
+	if(sp)
+	{
+		sp->EffectTriggerSpell[1] = 32865;
+		sp->procFlags = PROC_ON_DIE;
+	}*/
 	//winfury weapon changes. Start to hate these day by day
 	EnchantEntry * Enchantment = sEnchantStore.LookupEntry(283);
 	if(Enchantment)
